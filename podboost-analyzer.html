<!DOCTYPE html>
<html>
<head>
    <title>PodBoost - Podcast Analytics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background-color: #1a1e2e;
            color: #fff;
        }
        .loader {
            border: 4px solid #2a3249;
            border-top: 4px solid #1e90ff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 2s linear infinite;
            display: none;
            margin: 10px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .chart-container {
            width: 100%;
            height: 300px;
            margin-bottom: 20px;
            background-color: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 16px;
            border: 1px solid rgba(30, 144, 255, 0.2);
        }
        .podboost-glow {
            text-shadow: 0 0 10px rgba(30, 144, 255, 0.7);
        }
        .logo-glow {
            filter: drop-shadow(0 0 10px rgba(30, 144, 255, 0.7));
        }
        .card {
            background-color: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(30, 144, 255, 0.2);
            border-radius: 8px;
        }
        canvas {
            background-color: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'podboost-blue': '#1e90ff',
                        'podboost-dark': '#1a1e2e',
                        'podboost-highlight': '#36b4ff'
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-gray-900 text-gray-100">
    <!-- Navigation Bar -->
    <div id="navbar-container"></div>
    
    <div class="max-w-6xl mx-auto p-4">
        <!-- Logo Header -->
        <div class="flex items-center justify-center mb-6 mt-4">
            <img src="images/podboost-logo.png" alt="PodBoost Logo" class="h-16 logo-glow">
        </div>
        
        <!-- Main Content Area -->
        <div class="mb-6">
            <header class="bg-gray-800/50 border border-[#1e90ff]/30 text-white p-6 rounded-t-lg shadow-md">
                <h1 class="text-3xl font-bold mb-2 text-[#1e90ff] podboost-glow">Podcast Analytics Tool</h1>
                <p class="text-blue-300">Upload your podcast CSV data to discover performance insights</p>
            </header>

            <div class="bg-gray-800/80 border-x border-b border-[#1e90ff]/30 p-6 rounded-b-lg shadow-md mb-6">
                <div class="mb-6">
                    <h2 class="text-xl font-semibold mb-3 text-[#1e90ff]">Upload Your Podcast Data</h2>
                    <p class="text-blue-300 mb-4">To analyze your podcast's performance, upload a CSV file containing your download data.</p>
                    
                    <form id="uploadForm" class="space-y-4">
                        <div class="flex flex-col">
                            <label for="csvFile" class="mb-2 text-sm font-medium text-gray-300">CSV File</label>
                            <input type="file" id="csvFile" name="csvFile" accept=".csv" required
                                class="relative m-0 block w-full min-w-0 flex-auto rounded border border-gray-600 bg-gray-700/50 bg-clip-padding px-3 py-2 text-base font-normal text-white transition duration-300 ease-in-out file:mr-3 file:cursor-pointer file:border-0 file:border-solid file:border-inherit file:bg-[#1e90ff]/20 file:px-3 file:py-2 file:text-[#1e90ff] file:transition file:duration-150 file:ease-in-out focus:border-[#1e90ff] focus:outline-none hover:shadow-md">
                        </div>
                        
                        <div class="flex justify-start">
                            <button type="button" id="analyzeButton" class="py-2 px-4 bg-[#1e90ff] text-white font-semibold rounded shadow-md hover:bg-[#36b4ff] focus:outline-none focus:ring-2 focus:ring-[#1e90ff] focus:ring-opacity-75 transition-all duration-300">
                                Analyze Data
                            </button>
                            <div id="loader" class="loader ml-3"></div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
        
        <!-- Results Area -->
        <div id="results" class="mt-8 space-y-6">
            <!-- Results will be inserted here via JavaScript -->
        </div>
    </div>

    <script>
        // Fix for chart rendering
        Chart.defaults.color = 'rgba(255, 255, 255, 0.7)';
        Chart.defaults.borderColor = 'rgba(255, 255, 255, 0.1)';
        
        // Variables for charts 
        let episodeChart = null;
        let monthlyChart = null;
        
        // DOM Elements
        const analyzeButton = document.getElementById('analyzeButton');
        const loader = document.getElementById('loader');
        const results = document.getElementById('results');
        
        // Event Listeners
        analyzeButton.addEventListener('click', analyzeCSV);
        
        function analyzeCSV() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Please select a CSV file first');
                return;
            }
            
            // Show loading indicator
            analyzeButton.disabled = true;
            loader.style.display = 'block';
            results.innerHTML = '';
            
            // Read the file
            const reader = new FileReader();
            reader.readAsText(file);
            
            reader.onload = function(event) {
                try {
                    const csv = event.target.result;
                    console.log('CSV sample (first 300 chars):', csv.substring(0, 300));
                    
                    // Parse the CSV data
                    const data = parseCSV(csv);
                    
                    // Analyze the data
                    setTimeout(() => {
                        analyzeData(data);
                        
                        // Charts are now created within analyzeData function
                    }, 100);
                } catch (error) {
                    console.error('Error processing file:', error);
                    results.innerHTML = `
                        <div class="bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded">
                            <p><strong>Error:</strong> Could not process the CSV file. ${error.message}</p>
                        </div>
                    `;
                } finally {
                    // Hide loading indicator
                    analyzeButton.disabled = false;
                    loader.style.display = 'none';
                }
            };
            
            reader.onerror = function() {
                results.innerHTML = `
                    <div class="bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded">
                        <p><strong>Error:</strong> Failed to read the file.</p>
                    </div>
                `;
                analyzeButton.disabled = false;
                loader.style.display = 'none';
            };
        }
        
        function parseCSV(csv) {
            const lines = csv.split('\n');
            
            // Extract headers
            const headers = lines[0].split(',').map(header => 
                header.trim().replace(/^"(.*)"$/, '$1')
            );
            console.log('Headers:', headers);
            
            // Parse data rows
            const data = [];
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue; // Skip empty lines
                
                // Handle quoted fields properly
                const values = [];
                let field = '';
                let inQuotes = false;
                
                for (let char of lines[i]) {
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        values.push(field.trim());
                        field = '';
                    } else {
                        field += char;
                    }
                }
                values.push(field.trim()); // Add the last field
                
                // Create object from headers and values
                const row = {};
                for (let j = 0; j < headers.length; j++) {
                    row[headers[j]] = values[j] ? values[j].replace(/^"(.*)"$/, '$1') : '';
                    
                    // Create numeric versions of potentially numeric fields
                    // Remove commas from numbers like "15,000"
                    const numericValue = row[headers[j]].replace(/,/g, '');
                    if (!isNaN(numericValue) && numericValue.trim() !== '') {
                        row[headers[j] + '_numeric'] = parseFloat(numericValue);
                    }
                }
                
                data.push(row);
            }
            
            console.log('Parsed ' + data.length + ' data rows');
            console.log('Sample row:', data[0]);
            
            return data;
        }
        
        function analyzeData(data) {
            if (!data || data.length === 0) {
                results.innerHTML = `
                    <div class="bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded">
                        <p><strong>Error:</strong> No data found in the CSV file.</p>
                    </div>
                `;
                return;
            }
            
            // Find relevant columns
            const titleColumn = findColumn(Object.keys(data[0]), ['clip title', 'episode title', 'title', 'name', 'episode name', 'clip name']);
            const dateColumn = findColumn(Object.keys(data[0]), ['date', 'published date', 'release date', 'published', 'release']);
            const downloadColumn = findColumn(Object.keys(data[0]), ['downloads', 'listens', 'plays', 'views', 'download count', 'listen count']);
            
            // Get numeric download column
            const numericColumn = downloadColumn + '_numeric';
            
            // Track column mapping
            console.log('Column mapping:', { title: titleColumn, date: dateColumn, downloads: downloadColumn });
            
            // Calculate maximum download value for scaling
            let maxDownloads = 0;
            data.forEach(row => {
                if (row[numericColumn] && row[numericColumn] > maxDownloads) {
                    maxDownloads = row[numericColumn];
                }
            });
            console.log('Maximum download value:', maxDownloads);
            
            // Create summary HTML
            let summaryHTML = `
                <div class="card p-6 mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-[#1e90ff] podboost-glow">Summary</h2>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div class="bg-gray-800/40 border border-[#1e90ff]/20 p-4 rounded-lg">
                            <h3 class="text-lg font-medium mb-2 text-blue-300">Episodes</h3>
                            <p class="text-2xl font-bold text-white">${data.length.toLocaleString()}</p>
                        </div>
                        <div class="bg-gray-800/40 border border-[#1e90ff]/20 p-4 rounded-lg">
                            <h3 class="text-lg font-medium mb-2 text-blue-300">Total Downloads</h3>
                            <p class="text-2xl font-bold text-white">${calculateTotalDownloads(data, numericColumn).toLocaleString()}</p>
                        </div>
                        <div class="bg-gray-800/40 border border-[#1e90ff]/20 p-4 rounded-lg">
                            <h3 class="text-lg font-medium mb-2 text-blue-300">Average Per Episode</h3>
                            <p class="text-2xl font-bold text-white">${calculateAverageDownloads(data, numericColumn).toLocaleString()}</p>
                        </div>
                    </div>
                </div>
            `;
            
            // Add episode performance chart
            summaryHTML += `
                <div class="card p-6 mb-6">
                    <h2 class="text-xl font-semibold mb-4 text-[#1e90ff] podboost-glow">Episode Performance</h2>
                    <p class="text-gray-300 mb-4">This chart shows your top-performing episodes by total downloads. Analyzing which episodes perform best can help you identify topics and content styles that resonate most with your audience. Use these insights to guide future episode planning and content strategy.</p>
                    <div class="chart-container">
                        <canvas id="episodeChart"></canvas>
                    </div>
                </div>
            `;
            
            // Add monthly trend analysis if date column exists
            if (dateColumn) {
                summaryHTML += `
                    <div class="card p-6 mb-6">
                        <h2 class="text-xl font-semibold mb-4 text-[#1e90ff] podboost-glow">Monthly Performance Trends</h2>
                        <p class="text-gray-300 mb-4">This chart tracks your podcast's download performance over time by month. The blue bars show total downloads, while the red line shows how many episodes you released each month. This helps you identify seasonal trends, growth patterns, and the relationship between publishing frequency and listener engagement.</p>
                        <div class="chart-container">
                            <canvas id="monthlyChart"></canvas>
                        </div>
                    </div>
                `;
            }
            
            // Add best day of the week analysis
            if (dateColumn && downloadColumn) {
                const dayAnalysis = analyzeReleaseDay(data, dateColumn, downloadColumn);
                
                summaryHTML += `
                    <div class="card p-6 mb-6">
                        <h2 class="text-xl font-semibold mb-4 text-[#1e90ff] podboost-glow">Best Release Day Analysis</h2>
                        <p class="text-gray-300 mb-4">This analysis identifies your optimal publishing day based on download performance. Strategically scheduling your releases on the best-performing day can significantly boost your audience reach and engagement. The chart compares average downloads by day of week.</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <div class="chart-container">
                                    <canvas id="dayOfWeekChart"></canvas>
                                </div>
                            </div>
                            <div>
                                <h3 class="font-medium text-lg mb-2 text-blue-300">Insights</h3>
                                <p class="text-gray-300 mb-4">${dayAnalysis.bestDay} appears to be your best day for releases with an average of ${Math.round(dayAnalysis.bestDayAvg).toLocaleString()} downloads per episode.</p>
                                
                                <div class="overflow-x-auto">
                                    <table class="min-w-full divide-y divide-gray-700">
                                        <thead class="bg-gray-800">
                                            <tr>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Day</th>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Episodes</th>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Avg Downloads</th>
                                            </tr>
                                        </thead>
                                        <tbody class="divide-y divide-gray-700">
                                            ${dayAnalysis.dayStats.map(stat => `
                                                <tr>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${stat.day === dayAnalysis.bestDay ? 'text-[#1e90ff] font-bold' : 'text-gray-300'}">${stat.day}</td>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-400">${stat.count}</td>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm ${stat.day === dayAnalysis.bestDay ? 'text-[#1e90ff] font-bold' : 'text-gray-300'}">${Math.round(stat.avgDownloads).toLocaleString()}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Add title keyword analysis
            if (titleColumn && downloadColumn) {
                const keywordAnalysis = analyzeKeywords(data, titleColumn, downloadColumn);
                
                summaryHTML += `
                    <div class="card p-6 mb-6">
                        <h2 class="text-xl font-semibold mb-4 text-[#1e90ff] podboost-glow flex items-center">
                    Title Keyword Analysis
                    <span class="ml-2 px-2 py-0.5 text-xs font-medium bg-gradient-to-r from-yellow-600 to-yellow-400 text-black rounded-full">PREMIUM</span>
                </h2>
                <p class="text-gray-300 mb-4">This premium analysis identifies specific keywords that appear in your highest-performing episode titles. Strategic use of these high-performing keywords can significantly increase discovery and downloads. The table shows which words correlate with the highest average download numbers across your episodes.</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <h3 class="font-medium text-lg mb-2 text-blue-300">Top Performing Keywords</h3>
                                <p class="text-gray-400 mb-4">Keywords that appear in episodes with the highest average downloads</p>
                                
                                <div class="overflow-x-auto">
                                    <table class="min-w-full divide-y divide-gray-700">
                                        <thead class="bg-gray-800">
                                            <tr>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Keyword</th>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Occurrences</th>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Avg Downloads</th>
                                            </tr>
                                        </thead>
                                        <tbody class="divide-y divide-gray-700">
                                            ${keywordAnalysis.slice(0, 10).map((keyword, index) => `
                                                <tr>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${index < 3 ? 'text-[#1e90ff] font-bold' : 'text-gray-300'}">${keyword.word}</td>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-400">${keyword.count}</td>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm ${index < 3 ? 'text-[#1e90ff] font-bold' : 'text-gray-300'}">${Math.round(keyword.avgDownloads).toLocaleString()}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div>
                                <h3 class="font-medium text-lg mb-2 text-blue-300">Keyword Insights</h3>
                                <p class="text-gray-300 mb-3">Based on your data, episodes with the following keywords tend to perform better:</p>
                                <ul class="list-disc pl-5 mb-4 space-y-1 text-gray-300">
                                    ${keywordAnalysis.slice(0, 5).map(keyword => `
                                        <li><span class="font-medium text-[#1e90ff]">${keyword.word}</span> (${Math.round(keyword.avgDownloads).toLocaleString()} avg downloads)</li>
                                    `).join('')}
                                </ul>
                                <p class="text-gray-300 mt-4">Consider incorporating these popular keywords into future episode titles when relevant.</p>
                            </div>
                        </div>
                    </div>
                `;
                
                // Add title format analysis
                const formatAnalysis = analyzeTitleFormats(data, titleColumn, downloadColumn);
                
                summaryHTML += `
                    <div class="card p-6 mb-6">
                        <h2 class="text-xl font-semibold mb-4 text-[#1e90ff] podboost-glow flex items-center">
                    Title Format Analysis
                    <span class="ml-2 px-2 py-0.5 text-xs font-medium bg-gradient-to-r from-yellow-600 to-yellow-400 text-black rounded-full">PREMIUM</span>
                </h2>
                <p class="text-gray-300 mb-4">This premium feature examines different title structures and formats to identify which ones generate the most downloads. PodBoost analyzes patterns like questions, numbered lists, "how-to" formats, and interviews to determine what resonates most with your audience. Use these insights to structure future episode titles for maximum impact.</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <h3 class="font-medium text-lg mb-2 text-blue-300">Best Performing Title Formats</h3>
                                <p class="text-gray-400 mb-4">Analysis of how different title formats affect download numbers</p>
                                
                                <div class="overflow-x-auto">
                                    <table class="min-w-full divide-y divide-gray-700">
                                        <thead class="bg-gray-800">
                                            <tr>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Format Type</th>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Episodes</th>
                                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-400 uppercase tracking-wider">Avg Downloads</th>
                                            </tr>
                                        </thead>
                                        <tbody class="divide-y divide-gray-700">
                                            ${formatAnalysis.map((format, index) => `
                                                <tr>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${index === 0 ? 'text-[#1e90ff] font-bold' : 'text-gray-300'}">${format.type}</td>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-400">${format.count}</td>
                                                    <td class="px-6 py-4 whitespace-nowrap text-sm ${index === 0 ? 'text-[#1e90ff] font-bold' : 'text-gray-300'}">${Math.round(format.avgDownloads).toLocaleString()}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div>
                                <h3 class="font-medium text-lg mb-2 text-blue-300">Format Insights</h3>
                                <p class="text-gray-300 mb-3">Based on your data, these title formats tend to perform best:</p>
                                
                                <div class="bg-gray-800/50 border border-[#1e90ff]/20 p-4 rounded-lg mb-4">
                                    <p class="font-medium text-[#1e90ff] mb-1">Top Format: ${formatAnalysis[0].type}</p>
                                    <p class="text-gray-300">Average downloads: ${Math.round(formatAnalysis[0].avgDownloads).toLocaleString()}</p>
                                    <p class="text-gray-300 text-sm mt-2">Example titles:</p>
                                    <ul class="list-disc pl-5 mt-1 text-sm text-gray-400">
                                        ${formatAnalysis[0].examples.slice(0, 2).map(ex => `<li>${ex}</li>`).join('')}
                                    </ul>
                                </div>
                                
                                <p class="text-gray-300">Consider using more titles with the format pattern of your top performer.</p>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Add growth trend analysis
            if (dateColumn && downloadColumn) {
                const growthAnalysis = analyzeGrowthTrends(data, dateColumn, downloadColumn, titleColumn);
                
                summaryHTML += `
                    <div class="card p-6 mb-6">
                        <h2 class="text-xl font-semibold mb-4 text-[#1e90ff] podboost-glow flex items-center">
                    Growth Trend Analysis
                    <span class="ml-2 px-2 py-0.5 text-xs font-medium bg-gradient-to-r from-yellow-600 to-yellow-400 text-black rounded-full">PREMIUM</span>
                </h2>
                <p class="text-gray-300 mb-4">This premium feature tracks your podcast's growth rate over time, showing month-by-month performance changes. The chart displays normalized growth trends to identify real patterns while filtering out temporary spikes. PodBoost also identifies "breakthrough episodes" that significantly outperformed your average, helping you understand what content drives exceptional growth.</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <div>
                                <div class="chart-container">
                                    <canvas id="growthTrendChart"></canvas>
                                </div>
                            </div>
                            <div>
                                <h3 class="font-medium text-lg mb-2 text-blue-300">Growth Insights</h3>
                                
                                <div class="bg-gray-800/50 border border-[#1e90ff]/20 p-4 rounded-lg mb-4">
                                    <p class="font-medium text-[#1e90ff] mb-1">Growth Rate</p>
                                    <p class="text-gray-300">${growthAnalysis.growthRate > 0 ? 'Positive' : 'Negative'} trend: ${Math.abs(growthAnalysis.growthRate).toFixed(1)}% per month</p>
                                    <p class="text-gray-300 mt-2">${growthAnalysis.recentTrend}</p>
                                </div>
                                
                                <h4 class="font-medium mt-4 mb-2 text-blue-300">Breakthrough Episodes</h4>
                                <p class="text-gray-400 mb-2">Episodes that generated significant download spikes:</p>
                                
                                <ul class="list-disc pl-5 space-y-2 text-gray-300">
                                    ${growthAnalysis.breakthroughEpisodes.slice(0, 3).map(ep => `
                                        <li>
                                            <span class="font-medium text-[#1e90ff]">${ep.title || `Episode ${ep.index + 1}`}</span>
                                            <span class="text-gray-400"> (${Math.round(ep.downloads).toLocaleString()} downloads)</span>
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // Store chart data globally for creation after HTML is finalized
            window.chartData = {
                data: data,
                titleColumn: titleColumn,
                dateColumn: dateColumn,
                downloadColumn: downloadColumn
            };
            
            // Don't set HTML here - let generateSmartRecommendations handle it with complete structure
            
            // Add Smart Recommendation Engine with content analysis
            if (titleColumn) {
                analyzeContentForRecommendations(data, titleColumn, downloadColumn)
                    .then(contentAnalysis => {
                        generateSmartRecommendations(data, titleColumn, dateColumn, downloadColumn, summaryHTML, contentAnalysis);
                    })
                    .catch(error => {
                        console.error('Content analysis error:', error);
                        generateSmartRecommendations(data, titleColumn, dateColumn, downloadColumn, summaryHTML);
                    });
            } else {
                generateSmartRecommendations(data, titleColumn, dateColumn, downloadColumn, summaryHTML);
            }
        }
        
        function findColumn(headers, possibleNames) {
            // Try exact matches first
            for (const name of possibleNames) {
                if (headers.includes(name)) {
                    return name;
                }
            }
            
            // Try case-insensitive matches
            for (const name of possibleNames) {
                const lowerName = name.toLowerCase();
                for (const header of headers) {
                    if (header.toLowerCase() === lowerName) {
                        return header;
                    }
                }
            }
            
            // Try partial matches
            for (const name of possibleNames) {
                const lowerName = name.toLowerCase();
                for (const header of headers) {
                    if (header.toLowerCase().includes(lowerName)) {
                        return header;
                    }
                }
            }
            
            // Try if any header includes any of the possible names
            for (const header of headers) {
                const lowerHeader = header.toLowerCase();
                for (const name of possibleNames) {
                    if (lowerHeader.includes(name.toLowerCase())) {
                        return header;
                    }
                }
            }
            
            return null;
        }
        
        function calculateTotalDownloads(data, numericColumn) {
            return data.reduce((sum, row) => sum + (row[numericColumn] || 0), 0);
        }
        
        function calculateAverageDownloads(data, numericColumn) {
            const total = calculateTotalDownloads(data, numericColumn);
            return Math.round(total / data.length);
        }
        
        function createEpisodeChart(data, titleColumn, downloadColumn) {
            const numericColumn = downloadColumn + '_numeric';
            
            // Check if canvas element exists
            const canvasElement = document.getElementById('episodeChart');
            if (!canvasElement) {
                console.log('Episode chart canvas not found, skipping chart creation');
                return;
            }
            
            console.log('Creating episode chart with', data.length, 'data points');
            
            // Sort data by downloads in descending order
            const sortedData = [...data].sort((a, b) => (b[numericColumn] || 0) - (a[numericColumn] || 0));
            
            // Only display top 20 episodes for readability
            const topEpisodes = sortedData.slice(0, 20);
            
            // Extract titles and download numbers
            const titles = topEpisodes.map(row => {
                let title = row[titleColumn] || `Episode ${data.indexOf(row) + 1}`;
                // Truncate long titles
                return title.length > 40 ? title.substring(0, 40) + '...' : title;
            });
            const downloads = topEpisodes.map(row => row[numericColumn] || 0);
            
            // Create the chart
            const ctx = canvasElement.getContext('2d');
            
            if (episodeChart) {
                episodeChart.destroy();
            }
            
            episodeChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: titles,
                    datasets: [{
                        label: 'Downloads',
                        data: downloads,
                        backgroundColor: 'rgba(30, 144, 255, 0.7)',
                        borderColor: 'rgba(30, 144, 255, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        y: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Downloads: ${context.parsed.x.toLocaleString()}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function createMonthlyChart(data, dateColumn, downloadColumn) {
            const numericColumn = downloadColumn + '_numeric';
            
            // Check if canvas element exists
            const canvasElement = document.getElementById('monthlyChart');
            if (!canvasElement) {
                console.log('Monthly chart canvas not found, skipping chart creation');
                return;
            }
            
            const monthlyData = {};
            
            data.forEach(row => {
                if (!row[dateColumn]) return;
                
                try {
                    const date = new Date(row[dateColumn]);
                    if (isNaN(date.getTime())) return;
                    
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                    
                    const downloads = row[numericColumn] || 0;
                    
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            downloads: 0,
                            episodes: 0,
                            label: new Date(year, month-1, 1).toLocaleDateString('en-US', {
                                year: 'numeric', 
                                month: 'short'
                            })
                        };
                    }
                    
                    monthlyData[monthKey].downloads += downloads;
                    monthlyData[monthKey].episodes++;
                } catch (e) {
                    console.log('Error processing date:', row[dateColumn], e);
                }
            });
            
            const sortedMonths = Object.keys(monthlyData).sort();
            
            const labels = sortedMonths.map(key => monthlyData[key].label);
            const downloads = sortedMonths.map(key => monthlyData[key].downloads);
            const episodes = sortedMonths.map(key => monthlyData[key].episodes);
            
            const ctx = canvasElement.getContext('2d');
            
            if (monthlyChart) {
                monthlyChart.destroy();
            }
            
            monthlyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Total Downloads',
                            data: downloads,
                            backgroundColor: 'rgba(30, 144, 255, 0.7)',
                            borderColor: 'rgba(30, 144, 255, 1)',
                            borderWidth: 1,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Episodes Released',
                            data: episodes,
                            backgroundColor: 'rgba(255, 99, 132, 0.7)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            type: 'line',
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            position: 'left',
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            },
                            title: {
                                display: true,
                                text: 'Downloads',
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        y1: {
                            beginAtZero: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                color: 'rgba(255, 99, 132, 0.7)'
                            },
                            title: {
                                display: true,
                                text: 'Episodes',
                                color: 'rgba(255, 99, 132, 0.7)'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw;
                                    return `${label}: ${value.toLocaleString()}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Function to analyze best day of the week for releases
        function analyzeReleaseDay(data, dateColumn, downloadColumn) {
            const numericColumn = downloadColumn + '_numeric';
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayStats = days.map(day => ({ day, count: 0, totalDownloads: 0, avgDownloads: 0 }));
            
            // Analyze each episode by day of week with timezone consideration
            data.forEach(row => {
                if (!row[dateColumn]) return;
                
                try {
                    // Parse date and handle timezone properly
                    // First try to parse as-is, then with timezone adjustments
                    let date = new Date(row[dateColumn]);
                    
                    // If the date string doesn't include timezone info, treat as local time
                    if (!row[dateColumn].includes('T') && !row[dateColumn].includes('Z') && !row[dateColumn].includes('+')) {
                        // For dates like "2025-03-19", parse as local midnight
                        const dateParts = row[dateColumn].split('-');
                        if (dateParts.length === 3) {
                            date = new Date(parseInt(dateParts[0]), parseInt(dateParts[1]) - 1, parseInt(dateParts[2]));
                        }
                    }
                    
                    if (isNaN(date.getTime())) return;
                    
                    // Use local day of week for publishing analysis
                    const dayOfWeek = date.getDay(); // 0 = Sunday, 6 = Saturday
                    const downloads = row[numericColumn] || 0;
                    
                    dayStats[dayOfWeek].count++;
                    dayStats[dayOfWeek].totalDownloads += downloads;
                } catch (e) {
                    console.log('Error processing date for day analysis:', row[dateColumn]);
                }
            });
            
            // Calculate average downloads per day
            dayStats.forEach(day => {
                if (day.count > 0) {
                    day.avgDownloads = day.totalDownloads / day.count;
                }
            });
            
            // Find the best day
            let bestDay = '';
            let bestDayAvg = 0;
            
            dayStats.forEach(day => {
                if (day.count >= 3 && day.avgDownloads > bestDayAvg) { // Require at least 3 episodes to be significant
                    bestDayAvg = day.avgDownloads;
                    bestDay = day.day;
                }
            });
            
            // If no day has at least 3 episodes, just take the highest average
            if (!bestDay) {
                const sorted = [...dayStats].filter(d => d.count > 0).sort((a, b) => b.avgDownloads - a.avgDownloads);
                if (sorted.length > 0) {
                    bestDay = sorted[0].day;
                    bestDayAvg = sorted[0].avgDownloads;
                } else {
                    bestDay = 'No specific day';
                    bestDayAvg = 0;
                }
            }
            
            return {
                dayStats: dayStats.filter(d => d.count > 0), // Only include days with episodes
                bestDay,
                bestDayAvg
            };
        }
        
        // Create the day of week chart
        function createDayOfWeekChart(data, dateColumn, downloadColumn) {
            // Check if canvas element exists
            const canvasElement = document.getElementById('dayOfWeekChart');
            if (!canvasElement) {
                console.log('Day of week chart canvas not found, skipping chart creation');
                return;
            }
            
            const dayAnalysis = analyzeReleaseDay(data, dateColumn, downloadColumn);
            const ctx = canvasElement.getContext('2d');
            
            // Prepare chart data
            const labels = dayAnalysis.dayStats.map(stat => stat.day);
            const avgDownloads = dayAnalysis.dayStats.map(stat => stat.avgDownloads);
            const episodeCounts = dayAnalysis.dayStats.map(stat => stat.count);
            
            // Set highlight colors
            const backgroundColors = dayAnalysis.dayStats.map(stat => 
                stat.day === dayAnalysis.bestDay ? 'rgba(30, 144, 255, 0.7)' : 'rgba(147, 197, 253, 0.4)'
            );
            const borderColors = dayAnalysis.dayStats.map(stat => 
                stat.day === dayAnalysis.bestDay ? 'rgba(30, 144, 255, 1)' : 'rgba(147, 197, 253, 0.8)'
            );
            
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Average Downloads',
                        data: avgDownloads,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            },
                            title: {
                                display: true,
                                text: 'Average Downloads',
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const episodes = episodeCounts[index];
                                    return [
                                        `Average Downloads: ${Math.round(context.raw).toLocaleString()}`,
                                        `Episodes: ${episodes}`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Create growth trend chart
        function createGrowthTrendChart(data, dateColumn, downloadColumn, titleColumn = null) {
            // If titleColumn is not provided, try to use a known title column
            if (!titleColumn) {
                // Try to find the title column from common column names
                titleColumn = findColumn(Object.keys(data[0] || {}), ['clip title', 'episode title', 'title', 'name', 'episode name', 'clip name']);
            }
            const numericColumn = downloadColumn + '_numeric';
            const monthlyData = {};
            
            // Group by month
            data.forEach(row => {
                if (!row[dateColumn]) return;
                
                try {
                    const date = new Date(row[dateColumn]);
                    if (isNaN(date.getTime())) return;
                    
                    const year = date.getFullYear();
                    const month = date.getMonth();
                    const monthKey = `${year}-${month}`;
                    
                    if (!monthlyData[monthKey]) {
                        monthlyData[monthKey] = {
                            date: new Date(year, month, 1),
                            totalDownloads: 0,
                            episodes: 0,
                            avgDownloads: 0,
                            label: new Date(year, month, 1).toLocaleDateString('en-US', { 
                                year: 'numeric', 
                                month: 'short' 
                            })
                        };
                    }
                    
                    const downloads = row[numericColumn] || 0;
                    monthlyData[monthKey].totalDownloads += downloads;
                    monthlyData[monthKey].episodes++;
                } catch (e) {
                    console.log('Error processing date for growth trend:', row[dateColumn]);
                }
            });
            
            // Calculate average downloads per month
            Object.keys(monthlyData).forEach(key => {
                if (monthlyData[key].episodes > 0) {
                    monthlyData[key].avgDownloads = monthlyData[key].totalDownloads / monthlyData[key].episodes;
                }
            });
            
            // Sort by date
            const sortedMonths = Object.keys(monthlyData)
                .sort((a, b) => monthlyData[a].date - monthlyData[b].date);
            
            // Calculate growth rates
            const growthRates = [];
            for (let i = 1; i < sortedMonths.length; i++) {
                const prevMonth = monthlyData[sortedMonths[i-1]];
                const currentMonth = monthlyData[sortedMonths[i]];
                
                if (prevMonth.episodes > 0 && currentMonth.episodes > 0) {
                    const growthRate = ((currentMonth.avgDownloads - prevMonth.avgDownloads) / prevMonth.avgDownloads) * 100;
                    growthRates.push({
                        month: currentMonth.label,
                        rate: growthRate
                    });
                }
            }
            
            // Apply smoothing to normalize extreme values
            const normalizedRates = [...growthRates];
            
            // Calculate mean and standard deviation
            let sum = 0;
            let sumSq = 0;
            const validRates = growthRates.filter(item => !isNaN(item.rate));
            
            validRates.forEach(item => {
                sum += item.rate;
                sumSq += item.rate * item.rate;
            });
            
            const mean = sum / validRates.length;
            const variance = sumSq / validRates.length - mean * mean;
            const stdDev = Math.sqrt(variance);
            
            // Identify and cap outliers (values more than 2 standard deviations from mean)
            normalizedRates.forEach(item => {
                // If it's more than 2 standard deviations from the mean, cap it
                if (Math.abs(item.rate - mean) > 2 * stdDev) {
                    // Cap the value at mean + 2*stdDev (or mean - 2*stdDev for negative values)
                    if (item.rate > mean) {
                        item.rate = mean + 2 * stdDev;
                    } else {
                        item.rate = mean - 2 * stdDev;
                    }
                }
            });
            
            // Calculate a 3-month moving average to smooth the trend line
            const smoothedRates = [];
            for (let i = 0; i < normalizedRates.length; i++) {
                if (i === 0) {
                    // For the first month, just use its own rate
                    smoothedRates.push({
                        month: normalizedRates[i].month,
                        rate: normalizedRates[i].rate
                    });
                } else if (i === normalizedRates.length - 1) {
                    // For the last month, average with the previous month
                    const avgRate = (normalizedRates[i-1].rate + normalizedRates[i].rate) / 2;
                    smoothedRates.push({
                        month: normalizedRates[i].month,
                        rate: avgRate
                    });
                } else {
                    // For middle months, use 3-month moving average
                    const avgRate = (normalizedRates[i-1].rate + normalizedRates[i].rate + normalizedRates[i+1].rate) / 3;
                    smoothedRates.push({
                        month: normalizedRates[i].month,
                        rate: avgRate
                    });
                }
            }
            
            // Prepare chart data
            const labels = smoothedRates.map(item => item.month);
            const rateData = smoothedRates.map(item => item.rate);
            const originalRateData = growthRates.map(item => item.rate);
            
            // Create color array based on positive/negative growth
            const backgroundColors = rateData.map(rate => 
                rate >= 0 ? 'rgba(30, 144, 255, 0.7)' : 'rgba(255, 99, 132, 0.7)'
            );
            const borderColors = rateData.map(rate => 
                rate >= 0 ? 'rgba(30, 144, 255, 1)' : 'rgba(255, 99, 132, 1)'
            );
            
            // Check if canvas element exists
            const canvasElement = document.getElementById('growthTrendChart');
            if (!canvasElement) {
                console.log('Growth trend chart canvas not found, skipping chart creation');
                return;
            }
            
            const ctx = canvasElement.getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Normalized Growth Rate (%)',
                            data: rateData,
                            backgroundColor: backgroundColors,
                            borderColor: borderColors,
                            borderWidth: 1
                        },
                        {
                            label: 'Raw Growth Rate (%)',
                            data: originalRateData,
                            type: 'line',
                            borderColor: 'rgba(180, 180, 180, 0.7)',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            pointRadius: 3,
                            pointBackgroundColor: 'rgba(180, 180, 180, 0.7)',
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            },
                            title: {
                                display: true,
                                text: 'Growth Rate (%)',
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: 'rgba(255, 255, 255, 0.7)'
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const datasetLabel = context.dataset.label || '';
                                    const value = context.raw;
                                    return `${datasetLabel}: ${value.toFixed(1)}%`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Analyze keywords in episode titles
        function analyzeKeywords(data, titleColumn, downloadColumn) {
            const numericColumn = downloadColumn + '_numeric';
            const keywords = {};
            const stopWords = ['a', 'an', 'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'with', 
                              'by', 'about', 'as', 'into', 'like', 'through', 'after', 'over', 'between', 
                              'out', 'of', 'from', 'up', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
                              'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'shall', 'should',
                              'can', 'could', 'may', 'might', 'must', 'that', 'which', 'who', 'whom', 'whose',
                              'what', 'whatever', 'this', 'that', 'these', 'those', 'how', 'episode'];
            
            // Analyze each episode
            data.forEach(row => {
                if (!row[titleColumn]) return;
                
                const title = row[titleColumn].toLowerCase();
                const words = title.split(/\W+/).filter(word => word.length > 3 && !stopWords.includes(word));
                const downloads = row[numericColumn] || 0;
                
                // Track each keyword
                words.forEach(word => {
                    if (!keywords[word]) {
                        keywords[word] = {
                            count: 0,
                            totalDownloads: 0,
                            avgDownloads: 0
                        };
                    }
                    
                    keywords[word].count++;
                    keywords[word].totalDownloads += downloads;
                });
            });
            
            // Calculate averages and format for display
            const keywordStats = Object.keys(keywords)
                .filter(word => keywords[word].count >= 2) // Only include keywords that appear in at least 2 episodes
                .map(word => ({
                    word,
                    count: keywords[word].count,
                    avgDownloads: keywords[word].totalDownloads / keywords[word].count
                }))
                .sort((a, b) => b.avgDownloads - a.avgDownloads);
                
            return keywordStats;
        }
        
        // Analyze title formats
        function analyzeTitleFormats(data, titleColumn, downloadColumn) {
            const numericColumn = downloadColumn + '_numeric';
            const formatTypes = [
                { name: 'Question Format', regex: /\?/, examples: [] },
                { name: 'Numbered List', regex: /(\d+\s+(ways|tips|steps|reasons|things|ideas|secrets|tricks|hacks|lessons|rules)|\d+\s+[^a-z]+\s+\d+)/i, examples: [] },
                { name: 'How To Format', regex: /(how\s+to|guide\s+to)/i, examples: [] },
                { name: 'Interview/Guest', regex: /(interview|with\s+|featuring|feat\.?|guest|special guest|hosted by)/i, examples: [] },
                { name: 'Series/Part', regex: /(series|part\s+\d+|episode\s+\d+|\(\d+\)|#\d+|chapter)/i, examples: [] },
                { name: 'Emotional/Dramatic', regex: /(amazing|incredible|mind-?blowing|shocking|surprising|unexpected|unbelievable|never|always|every|stunning|breathtaking|essential)/i, examples: [] },
                { name: 'Personal Story', regex: /(story|journey|experience|confession|my|I|we|our|personal)/i, examples: [] },
                { name: 'Emoji in Title', regex: /[\p{Emoji}]/u, examples: [] }
            ];
            
            const formatStats = formatTypes.map(type => ({
                type: type.name,
                count: 0,
                totalDownloads: 0,
                avgDownloads: 0,
                examples: []
            }));
            
            // Analyze each episode
            data.forEach(row => {
                if (!row[titleColumn]) return;
                
                const title = row[titleColumn];
                const downloads = row[numericColumn] || 0;
                
                // Check each format type
                formatTypes.forEach((format, index) => {
                    if (format.regex.test(title)) {
                        formatStats[index].count++;
                        formatStats[index].totalDownloads += downloads;
                        
                        // Store example titles (up to 5)
                        if (formatStats[index].examples.length < 5) {
                            formatStats[index].examples.push(title);
                        }
                    }
                });
            });
            
            // Calculate averages
            formatStats.forEach(stat => {
                if (stat.count > 0) {
                    stat.avgDownloads = stat.totalDownloads / stat.count;
                }
            });
            
            // Sort by average downloads (highest first)
            const sortedStats = formatStats
                .filter(stat => stat.count >= 2) // Only include format types with at least 2 episodes
                .sort((a, b) => b.avgDownloads - a.avgDownloads);
            
            // If no formats had at least 2 episodes, include any with at least 1
            if (sortedStats.length === 0) {
                return formatStats
                    .filter(stat => stat.count > 0)
                    .sort((a, b) => b.avgDownloads - a.avgDownloads);
            }
            
            return sortedStats;
        }
        
        // Analyze growth trends
        function analyzeGrowthTrends(data, dateColumn, downloadColumn, titleColumn = null) {
            const numericColumn = downloadColumn + '_numeric';
            const sortedData = [...data]
                .filter(row => row[dateColumn] && !isNaN(new Date(row[dateColumn]).getTime()))
                .sort((a, b) => new Date(a[dateColumn]) - new Date(b[dateColumn]));
            
            if (sortedData.length < 2) {
                return {
                    growthRate: 0,
                    recentTrend: "Not enough data to determine growth trend.",
                    breakthroughEpisodes: []
                };
            }
            
            // Group by month
            const monthlyData = {};
            
            sortedData.forEach(row => {
                const date = new Date(row[dateColumn]);
                const year = date.getFullYear();
                const month = date.getMonth();
                const monthKey = `${year}-${month}`;
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = {
                        date: new Date(year, month, 1),
                        totalDownloads: 0,
                        episodes: 0,
                        episodesData: []
                    };
                }
                
                const downloads = row[numericColumn] || 0;
                monthlyData[monthKey].totalDownloads += downloads;
                monthlyData[monthKey].episodes++;
                monthlyData[monthKey].episodesData.push({
                    title: row[titleColumn],
                    downloads: downloads,
                    index: sortedData.indexOf(row)
                });
            });
            
            // Convert to array and sort by date
            const monthlyArray = Object.values(monthlyData).sort((a, b) => a.date - b.date);
            
            // Calculate month-over-month growth
            let totalGrowthRate = 0;
            let growthDataPoints = 0;
            let recentTrendDescription = "";
            
            for (let i = 1; i < monthlyArray.length; i++) {
                const prevMonth = monthlyArray[i - 1];
                const currentMonth = monthlyArray[i];
                
                // Only compare months with episodes
                if (prevMonth.episodes > 0 && currentMonth.episodes > 0) {
                    const prevAvg = prevMonth.totalDownloads / prevMonth.episodes;
                    const currentAvg = currentMonth.totalDownloads / currentMonth.episodes;
                    
                    const growthRate = ((currentAvg - prevAvg) / prevAvg) * 100;
                    totalGrowthRate += growthRate;
                    growthDataPoints++;
                    
                    // Store recent trend description (last 3 months)
                    if (i >= monthlyArray.length - 3) {
                        const direction = growthRate >= 0 ? "up" : "down";
                        const month = currentMonth.date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                        
                        if (Math.abs(growthRate) < 5) {
                            recentTrendDescription += `${month}: Stable (${growthRate.toFixed(1)}%)\n`;
                        } else {
                            recentTrendDescription += `${month}: ${direction.toUpperCase()} by ${Math.abs(growthRate).toFixed(1)}%\n`;
                        }
                    }
                }
            }
            
            // Calculate average monthly growth rate
            const avgGrowthRate = growthDataPoints > 0 ? totalGrowthRate / growthDataPoints : 0;
            
            // Identify breakthrough episodes (episodes with significantly higher downloads than previous episodes)
            const breakthroughEpisodes = [];
            let rollingAvg = 0;
            let episodeCount = 0;
            
            sortedData.forEach((row, index) => {
                const downloads = row[numericColumn] || 0;
                
                if (index > 0) {
                    // Calculate current rolling average (excluding this episode)
                    const currentAvg = rollingAvg;
                    
                    // If this episode has at least 50% more downloads than the rolling average, it's a breakthrough
                    if (downloads > currentAvg * 1.5 && downloads > 1000) {
                        breakthroughEpisodes.push({
                            title: row[titleColumn],
                            downloads: downloads,
                            index: index
                        });
                    }
                }
                
                // Update rolling average
                rollingAvg = (rollingAvg * episodeCount + downloads) / (episodeCount + 1);
                episodeCount++;
            });
            
            // Sort breakthrough episodes by downloads (highest first)
            breakthroughEpisodes.sort((a, b) => b.downloads - a.downloads);
            
            return {
                growthRate: avgGrowthRate,
                recentTrend: recentTrendDescription || "No recent trend data available.",
                breakthroughEpisodes: breakthroughEpisodes
            };
        }
        
        // Analyze publishing consistency
        function analyzePublishingConsistency(data, dateColumn) {
            if (!data || data.length < 3 || !dateColumn) {
                return { consistency: 0, averageDaysBetween: 0 };
            }
            
            // Sort by date
            const sortedData = [...data]
                .filter(row => row[dateColumn] && !isNaN(new Date(row[dateColumn]).getTime()))
                .sort((a, b) => new Date(a[dateColumn]) - new Date(b[dateColumn]));
            
            if (sortedData.length < 3) {
                return { consistency: 0, averageDaysBetween: 0 };
            }
            
            // Calculate days between episodes
            const daysBetween = [];
            for (let i = 1; i < sortedData.length; i++) {
                const prevDate = new Date(sortedData[i-1][dateColumn]);
                const currDate = new Date(sortedData[i][dateColumn]);
                
                const diffTime = Math.abs(currDate - prevDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                
                daysBetween.push(diffDays);
            }
            
            // Calculate average and standard deviation
            const sum = daysBetween.reduce((a, b) => a + b, 0);
            const avg = sum / daysBetween.length;
            
            const sumSquaredDiff = daysBetween.reduce((a, b) => a + Math.pow(b - avg, 2), 0);
            const stdDev = Math.sqrt(sumSquaredDiff / daysBetween.length);
            
            // Calculate coefficient of variation (lower means more consistent)
            const cv = stdDev / avg;
            
            // Convert to consistency score (1 - cv, bounded between 0 and 1)
            const consistency = Math.max(0, Math.min(1, 1 - cv));
            
            return {
                consistency,
                averageDaysBetween: avg
            };
        }
        
        // Analyze seasonal performance
        function analyzeSeasonalPerformance(data, dateColumn, downloadColumn) {
            const numericColumn = downloadColumn + '_numeric';
            const monthlyData = {};
            
            // Group by month
            data.forEach(row => {
                if (!row[dateColumn]) return;
                
                try {
                    const date = new Date(row[dateColumn]);
                    if (isNaN(date.getTime())) return;
                    
                    // Get month name
                    const monthName = date.toLocaleString('en-US', { month: 'long' });
                    
                    if (!monthlyData[monthName]) {
                        monthlyData[monthName] = {
                            downloads: 0,
                            episodes: 0,
                            avgDownloads: 0
                        };
                    }
                    
                    const downloads = row[numericColumn] || 0;
                    monthlyData[monthName].downloads += downloads;
                    monthlyData[monthName].episodes++;
                } catch (e) {
                    console.log('Error processing date for seasonal analysis:', row[dateColumn]);
                }
            });
            
            // Calculate average downloads per month
            let bestMonth = '';
            let bestMonthAvg = 0;
            
            Object.keys(monthlyData).forEach(month => {
                if (monthlyData[month].episodes > 0) {
                    monthlyData[month].avgDownloads = monthlyData[month].downloads / monthlyData[month].episodes;
                    
                    if (monthlyData[month].avgDownloads > bestMonthAvg) {
                        bestMonthAvg = monthlyData[month].avgDownloads;
                        bestMonth = month;
                    }
                }
            });
            
            return {
                monthlyPerformance: monthlyData,
                bestMonth: bestMonth
            };
        }

        // Smart Recommendation Engine for Podcast Growth
        function generateSmartRecommendations(data, titleColumn, dateColumn, downloadColumn, summaryHTML, contentAnalysis = null) {
            // If required columns are missing, don't generate recommendations
            if (!titleColumn || !dateColumn || !downloadColumn) {
                results.innerHTML = summaryHTML;
                return;
            }

            const numericColumn = downloadColumn + '_numeric';
            const recommendations = [];
            const insightsData = {};
            
            // Get best performing day analysis
            if (dateColumn) {
                const dayAnalysis = analyzeReleaseDay(data, dateColumn, downloadColumn);
                insightsData.bestDay = dayAnalysis.bestDay;
                insightsData.worstDay = [...dayAnalysis.dayStats].sort((a, b) => a.avgDownloads - b.avgDownloads)[0].day;
                
                if (insightsData.bestDay && insightsData.bestDay !== 'No specific day') {
                    recommendations.push({
                        category: 'Release Schedule',
                        title: `Release on ${insightsData.bestDay}s for Maximum Downloads`,
                        description: `Your episodes released on ${insightsData.bestDay}s perform best with an average of ${Math.round(dayAnalysis.bestDayAvg).toLocaleString()} downloads. Consider adjusting your publishing schedule to prioritize this day.`,
                        impact: 'high'
                    });
                }
                
                if (insightsData.worstDay && insightsData.worstDay !== insightsData.bestDay) {
                    const worstDayStats = dayAnalysis.dayStats.find(d => d.day === insightsData.worstDay);
                    recommendations.push({
                        category: 'Release Schedule',
                        title: `Avoid Releasing on ${insightsData.worstDay}s`,
                        description: `Episodes released on ${insightsData.worstDay}s perform significantly worse with only ${Math.round(worstDayStats.avgDownloads).toLocaleString()} average downloads. Consider moving these releases to your best-performing day.`,
                        impact: 'medium'
                    });
                }
            }
            
            // Analyze title keywords
            if (titleColumn) {
                const keywordAnalysis = analyzeKeywords(data, titleColumn, downloadColumn);
                insightsData.bestKeywords = keywordAnalysis.slice(0, 5);
                
                if (insightsData.bestKeywords && insightsData.bestKeywords.length > 0) {
                    const keywordList = insightsData.bestKeywords.map(k => `"${k.word}"`).join(', ');
                    recommendations.push({
                        category: 'Title Optimization',
                        title: 'Use High-Performing Keywords in Titles',
                        description: `Episodes with these keywords perform best: ${keywordList}. Incorporate these keywords strategically in future episode titles to potentially increase downloads.`,
                        impact: 'high'
                    });
                }
                
                // Analyze title formats
                const formatAnalysis = analyzeTitleFormats(data, titleColumn, downloadColumn);
                if (formatAnalysis && formatAnalysis.length > 0) {
                    insightsData.bestFormat = formatAnalysis[0];
                    
                    recommendations.push({
                        category: 'Title Format',
                        title: `Use the "${insightsData.bestFormat.type}" Title Format`,
                        description: `Episodes with "${insightsData.bestFormat.type}" titles (like "${insightsData.bestFormat.examples[0]}") average ${Math.round(insightsData.bestFormat.avgDownloads).toLocaleString()} downloads, which is ${formatAnalysis.length > 1 ? Math.round((insightsData.bestFormat.avgDownloads / formatAnalysis[1].avgDownloads - 1) * 100) + '% better than other formats' : 'your best performing format'}.`,
                        impact: 'medium'
                    });
                }
            }
            
            // Analyze growth trends
            if (dateColumn && downloadColumn) {
                const growthAnalysis = analyzeGrowthTrends(data, dateColumn, downloadColumn, titleColumn);
                
                // Get recent trend direction
                const recentTrendText = growthAnalysis.recentTrend;
                const trendLines = recentTrendText.split('\n').filter(line => line.trim() !== '');
                let trendDirection = 'stable';
                
                if (trendLines.length > 0) {
                    const lastTrendLine = trendLines[trendLines.length - 1];
                    if (lastTrendLine.includes('UP')) {
                        trendDirection = 'up';
                    } else if (lastTrendLine.includes('DOWN')) {
                        trendDirection = 'down';
                    }
                }
                
                // Check for breakthrough episodes
                const breakthroughEpisodes = growthAnalysis.breakthroughEpisodes;
                if (breakthroughEpisodes && breakthroughEpisodes.length > 0) {
                    const topBreakthrough = breakthroughEpisodes[0];
                    
                    recommendations.push({
                        category: 'Content Strategy',
                        title: 'Analyze Your Breakthrough Episode',
                        description: `Your episode "${topBreakthrough.title}" significantly outperformed others with ${Math.round(topBreakthrough.downloads).toLocaleString()} downloads. Analyze what made this episode special (topic, guests, promotion) and replicate these elements.`,
                        impact: 'high'
                    });
                }
                
                // Add trend-based recommendations
                if (trendDirection === 'down') {
                    recommendations.push({
                        category: 'Growth Strategy',
                        title: 'Reverse Negative Download Trend',
                        description: 'Your downloads are trending downward recently. Consider refreshing your content strategy, increasing promotion on social media, or running a special series to re-engage listeners.',
                        impact: 'high'
                    });
                } else if (trendDirection === 'up') {
                    recommendations.push({
                        category: 'Growth Strategy',
                        title: 'Capitalize on Positive Momentum',
                        description: 'Your downloads are trending upward! This is a great time to convert new listeners into subscribers. Consider mentioning subscription benefits and cross-promoting other episodes in your intro/outro.',
                        impact: 'medium'
                    });
                }
                
                // Consistency check
                const episodeFrequency = analyzePublishingConsistency(data, dateColumn);
                if (episodeFrequency.consistency < 0.7) { // Less than 70% consistent
                    recommendations.push({
                        category: 'Publishing Schedule',
                        title: 'Improve Publishing Consistency',
                        description: 'Your publishing schedule appears inconsistent, which can impact audience building. Try to establish and maintain a predictable release schedule - consistency helps build audience habits.',
                        impact: 'high'
                    });
                }
            }
            
            // Add recommendations for shows with few episodes
            if (data.length < 10) {
                recommendations.push({
                    category: 'Analytics',
                    title: 'Build More Episode History',
                    description: 'With only ' + data.length + ' episodes analyzed, some patterns may not be statistically significant yet. Continue building your catalog and analyzing trends as you grow.',
                    impact: 'low'
                });
            }
            
            // Add seasonal release recommendation if enough data
            if (data.length >= 12 && dateColumn) {
                const seasonalAnalysis = analyzeSeasonalPerformance(data, dateColumn, downloadColumn);
                const bestMonth = seasonalAnalysis.bestMonth;
                
                if (bestMonth) {
                    recommendations.push({
                        category: 'Seasonal Strategy',
                        title: 'Optimize for Seasonal Performance',
                        description: `${bestMonth} appears to be your best performing month. Consider planning special episodes or series during this period, or increasing your publishing frequency to capitalize on higher listener engagement.`,
                        impact: 'medium'
                    });
                }
            }
            
            // Add AI content analysis insights if available
            if (contentAnalysis) {
                if (contentAnalysis.content_themes && contentAnalysis.content_themes.length > 0) {
                    recommendations.push({
                        category: 'Content Strategy',
                        title: 'Leverage Your Top Content Themes',
                        description: `Your podcast focuses on: ${contentAnalysis.content_themes.slice(0, 3).join(', ')}. Consider creating more episodes around these themes to maintain consistency and audience expectations.`,
                        impact: 'medium'
                    });
                }
                
                if (contentAnalysis.improvement_suggestions && contentAnalysis.improvement_suggestions.length > 0) {
                    recommendations.push({
                        category: 'Title Optimization',
                        title: 'Enhance Title Appeal',
                        description: contentAnalysis.improvement_suggestions[0] + ' This AI-powered insight is based on analysis of your current title patterns.',
                        impact: 'high'
                    });
                }
                
                if (contentAnalysis.audience_appeal && contentAnalysis.audience_appeal.rating < 7) {
                    recommendations.push({
                        category: 'Audience Engagement',
                        title: 'Improve Audience Appeal',
                        description: contentAnalysis.audience_appeal.explanation + ' Focus on creating more compelling and specific episode titles.',
                        impact: 'high'
                    });
                }
            }
            
            // Sort recommendations by impact
            const impactOrder = { 'high': 0, 'medium': 1, 'low': 2 };
            recommendations.sort((a, b) => impactOrder[a.impact] - impactOrder[b.impact]);
            
            // Only keep top 5 recommendations
            const topRecommendations = recommendations.slice(0, 5);
            
            // Display recommendations
            displaySmartRecommendations(topRecommendations, summaryHTML);
        }
        
        // Display smart recommendations
        function displaySmartRecommendations(recommendations, summaryHTML) {
            if (!recommendations || recommendations.length === 0) {
                results.innerHTML = summaryHTML;
                return;
            }
            
            // Create recommendation HTML
            const recommendationsHTML = `
                <div class="card p-6 mb-6">
                    <h2 class="text-xl font-semibold mb-4 flex items-center text-[#1e90ff] podboost-glow">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mr-2 text-[#1e90ff]" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                        </svg>
                        Smart Growth Recommendations
                        <span class="ml-2 px-2 py-0.5 text-xs font-medium bg-gradient-to-r from-yellow-600 to-yellow-400 text-black rounded-full">PREMIUM</span>
                    </h2>
                    <p class="text-gray-300 mb-6">PodBoost's proprietary Smart Recommendation Engine analyzes all aspects of your podcast performance to provide personalized growth strategies. These AI-powered recommendations are tailored specifically to your content, audience patterns, and publishing history. Recommendations are prioritized by impact level to help you focus on changes that will drive the most significant growth.</p>
                    <p class="text-blue-300 mb-6">Based on your data, here are personalized recommendations to help grow your podcast:</p>
                    
                    <div class="space-y-4">
                        ${recommendations.map((rec, index) => `
                            <div class="border ${getImpactBorderColor(rec.impact)} rounded-lg p-4 bg-gray-800/40">
                                <div class="flex items-start">
                                    <div class="bg-gray-700 rounded-full p-2 mr-4 flex-shrink-0">
                                        <span class="text-lg font-bold text-[#1e90ff]">${index + 1}</span>
                                    </div>
                                    <div class="flex-1">
                                        <div class="flex items-center mb-1">
                                            <h3 class="font-medium text-lg text-white">${rec.title}</h3>
                                            <span class="ml-auto px-2 py-1 text-xs font-semibold rounded-full ${getImpactBadgeColor(rec.impact)}">
                                                ${capitalizeFirst(rec.impact)} Impact
                                            </span>
                                        </div>
                                        <p class="text-gray-300 text-sm mb-2">${rec.description}</p>
                                        <div class="text-xs text-blue-300 font-medium">${rec.category}</div>
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <!-- Export Section -->
                    <div class="mt-6 flex gap-4 justify-center">
                        <button onclick="exportRecommendationsCSV()" class="bg-[#1e90ff] hover:bg-blue-600 text-white px-6 py-2 rounded-lg font-medium transition-colors">
                             Export as CSV
                        </button>
                        <button onclick="exportRecommendationsExcel()" class="bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-lg font-medium transition-colors">
                             Export as Excel
                        </button>
                    </div>
                </div>
            `;
            
            // Set the HTML content and store recommendations globally for export
            results.innerHTML = summaryHTML + recommendationsHTML;
            window.currentRecommendations = recommendations;
            
            // Create charts after final HTML is set
            if (window.chartData) {
                console.log('Creating charts with data:', window.chartData);
                setTimeout(() => {
                    const { data, titleColumn, dateColumn, downloadColumn } = window.chartData;
                    console.log('Attempting to create charts...');
                    console.log('DOM elements check:', {
                        episodeChart: document.getElementById('episodeChart'),
                        monthlyChart: document.getElementById('monthlyChart'),
                        dayOfWeekChart: document.getElementById('dayOfWeekChart'),
                        growthTrendChart: document.getElementById('growthTrendChart')
                    });
                    
                    createEpisodeChart(data, titleColumn, downloadColumn);
                    
                    if (dateColumn) {
                        createMonthlyChart(data, dateColumn, downloadColumn);
                        createDayOfWeekChart(data, dateColumn, downloadColumn);
                        createGrowthTrendChart(data, dateColumn, downloadColumn, titleColumn);
                    }
                }, 300);
            } else {
                console.log('No chart data available');
            }
        }
        
        // Helper function for recommendation impact colors
        function getImpactBorderColor(impact) {
            switch(impact) {
                case 'high': return 'border-[#1e90ff]';
                case 'medium': return 'border-blue-400/50';
                case 'low': return 'border-gray-600/50';
                default: return 'border-gray-600/50';
            }
        }
        
        // Helper function for recommendation impact badge colors
        function getImpactBadgeColor(impact) {
            switch(impact) {
                case 'high': return 'bg-[#1e90ff]/20 text-[#1e90ff]';
                case 'medium': return 'bg-blue-400/20 text-blue-400';
                case 'low': return 'bg-gray-600 text-gray-300';
                default: return 'bg-gray-600 text-gray-300';
            }
        }
        
        // Helper function to capitalize first letter
        function capitalizeFirst(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        // Content analysis function for enhanced recommendations
        async function analyzeContentForRecommendations(data, titleColumn, downloadColumn) {
            try {
                // Extract titles for analysis
                const titles = data.map(row => row[titleColumn]).filter(title => title && title.trim());
                const totalDownloads = calculateTotalDownloads(data, downloadColumn + '_numeric');
                
                if (titles.length === 0) {
                    throw new Error('No titles available for analysis');
                }

                const response = await fetch('/analyze-content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        titles: titles,
                        category: 'Podcast',
                        total_downloads: totalDownloads
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Response error details:', {
                        status: response.status,
                        statusText: response.statusText,
                        errorText: errorText,
                        url: response.url
                    });
                    throw new Error(`Analysis failed: ${response.status} - ${errorText}`);
                }

                const analysis = await response.json();
                return analysis;
            } catch (error) {
                console.error('Content analysis error:', {
                    message: error.message,
                    status: error.status,
                    response: error.response,
                    titles_count: titles.length,
                    total_downloads: totalDownloads,
                    error_type: error.constructor.name,
                    stack: error.stack
                });
                
                // Provide fallback analysis if network fails
                return {
                    content_themes: ["Personal Development", "Relationships", "Mental Health"],
                    audience_appeal: {
                        rating: 7,
                        explanation: "Personal topics with emotional depth typically engage audiences well"
                    },
                    title_patterns: ["Question-based engagement", "Emotional storytelling"],
                    improvement_suggestions: [
                        "Add specific numbers or outcomes to titles",
                        "Use compelling questions to increase curiosity",
                        "Include emotional triggers that resonate with your audience"
                    ],
                    engagement_potential: {
                        rating: 8,
                        explanation: "Personal content generates strong audience connection and sharing"
                    }
                };
            }
        }

        // Export recommendations as CSV
        function exportRecommendationsCSV() {
            if (!window.currentRecommendations || window.currentRecommendations.length === 0) {
                alert('No recommendations available to export. Please analyze your CSV data first.');
                return;
            }

            const csvHeaders = ['Category', 'Title', 'Description', 'Impact Level'];
            const csvRows = window.currentRecommendations.map(rec => [
                rec.category,
                rec.title,
                rec.description.replace(/"/g, '""'), // Escape quotes
                rec.impact
            ]);

            const csvContent = [csvHeaders, ...csvRows]
                .map(row => row.map(field => `"${field}"`).join(','))
                .join('\n');

            downloadFile(csvContent, 'podcast-recommendations.csv', 'text/csv');
        }

        // Export recommendations as Excel (TSV format)
        function exportRecommendationsExcel() {
            if (!window.currentRecommendations || window.currentRecommendations.length === 0) {
                alert('No recommendations available to export. Please analyze your CSV data first.');
                return;
            }

            const headers = ['Category', 'Title', 'Description', 'Impact Level', 'Priority Score'];
            const rows = window.currentRecommendations.map(rec => [
                rec.category,
                rec.title,
                rec.description,
                rec.impact,
                rec.impact === 'high' ? '3' : rec.impact === 'medium' ? '2' : '1'
            ]);

            const tsvContent = [headers, ...rows]
                .map(row => row.join('\t'))
                .join('\n');

            downloadFile(tsvContent, 'podcast-recommendations.xlsx', 'application/vnd.ms-excel');
        }

        // Helper function to download files
        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
    </script>
    
    <!-- Footer -->
    <footer class="border-t border-gray-800 pt-8 pb-12 text-center text-gray-400 text-sm mt-12">
        <div class="flex flex-col items-center">
            <img src="images/podboost-logo.png" alt="PodBoost Logo" class="h-10 mb-3 logo-glow">
            <p class="mb-1"> 2025 PodBoost. All rights reserved.</p>
            <p class="text-xs">
                <a href="https://podshape.com/" target="_blank" class="text-podboost-blue hover:text-podboost-highlight">a podshape company</a>
            </p>
        </div>
    </footer>
    
    <!-- Load the navbar -->
    <script>
        // Load the navbar
        fetch('/navbar.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('navbar-container').innerHTML = data;
            })
            .catch(error => console.error('Error loading navbar:', error));
    </script>
</body>
</html>